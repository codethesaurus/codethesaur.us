{
  "meta": {
    "language": "javascript",
    "language_name": "JavaScript",
    "structure": "queues_stacks",
    "language_version": "ECMAScript 2020"
  },
  "concepts": {
    "simple_queue_import_statement": {
      "name": "Import statement to add simple queue",
      "not-implemented":"true",
      "comment":"There is no queue library in JavaScript"
    },
    "simple_queue_data_type": {
      "name": "Queue data type name",
      "code": [
        "Array [] or class"
      ]
    },
    "simple_queue_create_statement": {
      "name": "Create a queue",
      "code": [
        "//Using array\nlet queue = ['item1','item2','item3']\n//Using linked list\n data = queue()"
      ]
    },
    "simple_queue_create_copy_statement": {
      "name": "Create a queue from existing queue",
      "code": [
        "//Using slice method\n let copyqueue=queue.slice()\n//Using spread operator\n let copyqueue = [...queue]\n//For linked list(implementation down below)\n copyqueue=prevqueue.copy()"
      ]
    },
    "simple_queue_create_copy_from_list_statement": {
      "name": "Create a queue from a list of items",
      "code": [
        "//Using slice method\n let copyqueue=datalist.slice()\n//Using spread operator\n let copyqueue = [...datalist]\n//Using linked list\n copyqueue = queue(datalist) "
      ]
    },
    "simple_queue_destroy_statement": {
      "name": "Destroy/delete a queue",
      "code": [
        "queue = [] \n//Using linked list(implementation below) dataqueue.delete()"
      ]
    },
    "simple_queue_data_structure": {
      "name": "Data structure that backs the simple queue",
      "code": [
        "//Using array \nqueue = [] \n//Using linked list\nclass node\n {\n constructor(data){\n this.data = data;\n this.next = null;\n }\n }\n class queue\n {\n constructor(data=[])\n {\n this.front=null;\n this.rear=null;\n for(let i of data){\n this.push(i)\n }\n }\n copy(){\n let data=[]\n if (this.front == null)return null;\n let temp=this.front;\n while(temp!=null){\n data.push(temp.data)\n temp=temp.next\n }\n return new queue(data);\n }\n delete(){\n this.front=null\n this.rear=null\n }\n push(n){\n let temp =new node(n);\n if(this.front == null){\n this.front = temp;\n }\n else{\n this.rear.next= temp;\n }\n this.rear = temp;\n }\n display(){\n let temp = this.front;\n while(temp!=null){\n console.log(temp.data);\n temp = temp.next;\n }\n }\n pop(){\n this.front=this.front.next;\n }\n }\n"
      ]
    },
    "circular_queue_import_statement": {
      "name": "Import statement to add simple queue",
      
      "not-implemented":"true",
      "comment":"There is no queue library in JavaScript"
    },
    "circular_queue_data_type": {
      "name": "Queue data type name",
      "code": [
        "Array [] or class"
      ]
    },
    "circular_queue_create_statement": {
      "name": "Create a queue",
      "code": [
        "//Using array\nlet queue = ['item1','item2','item3']\n//Using linked list\n data = queue()"
      ]
    },
    "circular_queue_create_copy_statement": {
      "name": "Create a queue from existing queue",
      "code": [
        "//Using slice method\n let copyqueue=queue.slice()\n//Using spread operator\n let copyqueue = [...queue]\n//For linked list(implementation down below)\n copyqueue=prevqueue.copy()"
      ]
    },
    "circular_queue_create_copy_from_list_statement": {
      "name": "Create a queue from a list of items",
      "code": [
        "//Using slice method\n let copyqueue=datalist.slice()\n//Using spread operator\n let copyqueue = [...datalist]\n//Using linked list\n copyqueue = queue(datalist) "
      ]
    },
    "circular_queue_destroy_statement": {
      "name": "Destroy/delete a queue",
      "code": [
        "queue = [] \n//Using linked list(implementation below) dataqueue.delete()"
      ]
    },
    "circular_queue_data_structure": {
      "name": "Data structure that backs the simple queue",
      "code": [
        "//Using array \nqueue = [] \n//Using linked list\nclass node\n {\n constructor(data){\n this.data = data;\n this.next = null;\n }\n }\n class queue\n {\n constructor(data=[])\n {\n this.front=null;\n this.rear=null;\n for(let i of data){\n this.push(i)\n }\n }\n copy(){\n let data=[]\n if (this.front == null)return null;\n let temp=this.front;\n while(temp!=null){\n data.push(temp.data)\n temp=temp.next\n }\n return new queue(data)\n }\n delete(){\n this.front=null\n this.rear=null\n }\n push(n){\n let temp =new node(n);\n if(this.front == null){\n this.front = temp;\n }\n else{\n this.rear.next= temp;\n }\n this.rear = temp;\n this.rear.next = this.front\n }\n display(){\n console.log(this.front.data)\n let temp = this.front.next;\n front){\n console.log(temp.data);\n temp = temp.next;\n }\n }\n pop(){\n this.front=this.front.next;\n }\n }\n"
      ]
    },
    
    "not-implementedrity_queue_import_statement": {
      "name": "Import statement to add not-implementedrity queue",
      
      "not-implemented":"true"
    },
    "not-implementedrity_queue_data_type": {
      "name": "Queue data type name",
      "code": [
        "Array [] or class"
      ]
    },
    "not-implementedrity_queue_create_statement": {
      "name": "Create a queue",
      "code": [
        "//Using array\nlet queue = [['item1',not-implementedrity],['item2',not-implementedrity],['item3',not-implementedrity]]\n//Using linked list\n data = not-implementedrity_queue()"
      ]
    },
    "not-implementedrity_queue_create_copy_statement": {
      "name": "Create a queue from existing queue",
      "code": [
        "//Using slice method\n let copyqueue=queue.slice()\n//Using spread operator\n let copyqueue = [...queue]\n//For linked list(implementation down below)\n copyqueue=prevqueue.copy()"
      ]
    },
    "not-implementedrity_queue_create_copy_from_list_statement": {
      "name": "Create a queue from a list of items",
      "code": [
        "//Using slice method\n let copyqueue=datalist.slice()\n//Using spread operator\n let copyqueue = [...datalist]\n//Using linked list\n copyqueue = queue(datalist) "
      ]
    },
    "not-implementedrity_queue_destroy_statement": {
      "name": "Destroy/delete a queue",
      "code": [
        "queue = [] \n//Using linked list(implementation below) dataqueue.delete()"
      ]
    },
    "not-implementedrity_queue_data_structure": {
      "name": "Data structure that backs the not-implementedrity queue",
      "code": [
        "let pr_queue=[]\n//Using linked list\nclass node\n {\n constructor(value,not-implementedrity){\n this.value=value\n this.next=null\n this.not-implementedrity=not-implementedrity\n }\n }\n \n class not-implementedrity_queue\n {\n constructor(){\n this.front=null;\n this.rear=null;\n this.max_not-implementedrity=0;\n }\n push(n,not-implementedrity){\n let temp = new node(n,not-implementedrity);\n if(this.front == null){\n this.front = temp;\n this.rear = temp;\n }\n else{\n if(not-implementedrity>this.max_not-implementedrity){\n this.rear.next = temp;\n this.rear = temp;\n this.max_not-implementedrity=not-implementedrity;\n }\n else{\n let iterator = this.front;\n let more_not-implementedrity_node = this.front.next\n while(iterator.next.not-implementedrity<not-implementedrity){\n iterator=iterator.next\n more_not-implementedrity_node=more_not-implementedrity_node.next\n }\n iterator.next=temp;\n temp.next=more_not-implementedrity_node;\n }\n }\n }\n display(){\n let temp = this.front;\n while(temp!=null){\n console.log(temp.value+' ');\n temp=temp.next\n }\n }\n pop(){\n if(this.front!=null){\n this.front=this.front.next;\n }\n }\n delete(){\n this.front=null;\n this.rear=null;\n }\n }\n"
      ]
    },
    "double_ended_queue_import_statement": {
      "name": "Import statement to add double-ended queue",
      
      "not-implemented":"true"
    },
    "double_ended_queue_data_type": {
      "name": "Queue data type name",
      "code": [
        "Array [] or class"
      ]
    },
    "double_ended_queue_create_statement": {
      "name": "Create a queue",
      "code": [
        "//Using array\nlet queue = ['item1','item2','item3']\n//Using linked list\n data = queue()"
      ]
    },
    "double_ended_queue_create_copy_statement": {
      "name": "Create a queue from existing queue",
      "code": [
        "//Using slice method\n let copyqueue=datalist.slice()\n//Using spread operator\n let copyqueue = [...datalist]\n//Using linked list\n copyqueue = queue(datalist) "
      ]
    },
    "double_ended_queue_create_copy_from_list_statement": {
      "name": "Create a queue from a list",
      "code": [
        "queue = [] \n//Using linked list(implementation below) dataqueue.delete()"
      ]
    },
    "double_ended_queue_destroy_statement": {
      "name": "Destroy/delete a queue",
      "code": [
        "//Using array \nqueue = [] \n//Using linked list\nclass node\n {\n constructor(data){\n this.data = data;\n this.next = null;\n }\n }\n class queue\n {\n constructor(data=[])\n {\n this.front=null;\n this.rear=null;\n for(let i of data){\n this.push(i)\n }\n }\n copy(){\n let data=[]\n if (this.front == null)return null;\n let temp=this.front;\n while(temp!=null){\n data.push(temp.data)\n temp=temp.next\n }\n return new queue(data);\n }\n delete(){\n this.front=null\n this.rear=null\n }\n push(n){\n let temp =new node(n);\n if(this.front == null){\n this.front = temp;\n }\n else{\n this.rear.next= temp;\n }\n this.rear = temp;\n }\n display(){\n let temp = this.front;\n while(temp!=null){\n console.log(temp.data);\n temp = temp.next;\n }\n }\n pop(){\n this.front=this.front.next;\n }\n }\n"
      ]
    },
    "double_ended_queue_data_structure": {
      "name": "Data structure that backs the simple queue",
      "code": [
        "let queue=[]\n//Using doubly linked list\nclass node\n {\n constructor(data){\n this.data = data;\n this.next = null;\n this.prev = null;\n }\n }\n \n class double_ended_queue\n {\n constructor(data=[])\n {\n this.front=null;\n this.rear=null;\n for(let i of data){\n this.push(i)\n }\n }\n copy(){\n let data=[]\n if (this.front == null)return null;\n let temp=this.front;\n while(temp!=null){\n data.push(temp.data)\n temp=temp.next\n }\n return new queue(data)\n }\n delete(){\n this.front=null\n this.rear=null\n }\n push(n){\n let temp =new node(n);\n if(this.front == null){\n this.front = temp;\n }\n else{\n temp.prev=this.rear;\n this.rear.next= temp;\n }\n this.rear = temp;\n }\n display(){\n let temp = this.front;\n while(temp!=null){\n console.log(temp.data);\n temp = temp.next;\n }\n }\n display_rev(){\n let temp = this.rear;\n while(temp!=null){\n console.log(temp.data);\n temp = temp.prev;\n }\n }\n pop_front(){\n this.front=this.front.next;\n }\n pop_rear(){\n this.rear=this.rear.prev;\n }\n }\n"
      ]
    },
    "stack_import_statement": {
      "name": "Import statement to add stacks",
      
      "not-implemented":"true"
    },
    "stack_data_type": {
      "name": "Stack data type name",
      "code": [
        "Array [] or class"
      ]
    },
    "stack_create_statement": {
      "name": "Create a stack",
      "code": [
        " stack = [] \n //Using linked list(code below)\nstackdata=stack()"
      ]
    },
    "stack_create_copy_statement": {
      "name": "Create a stack from existing stack",
      "code": [
        "//Using slice method\n let copystack=stack.slice()\n//Using spread operator\n let copystack = [...stack]\n//For linked list(implementation down below)\n copystack=prevstack.copy()"
      ]
    },
    "stack_create_copy_from_list_statement": {
      "name": "Create a stack from a list",
      "code": [
        "//Using slice method\n let copystack=stack.slice()\n//Using spread operator\n let copystack = [...stack]\n//For linked list(implementation down below)\n copystack=stack(listdata)"
      ]
    },
    "stack_destroy_statement": {
      "name": "Destroy/delete a stack",
      "code": [
        "stack = []\n//Using linked list\nstackdata.delete()"
      ]
    },
    "stack_data_structure": {
      "name": "Data structure that backs the stack",
      "code": [
        "//Array Representation\n let stack=[]//Using linked list\nclass node\n {\n constructor(data){\n this.data = data;\n this.prev = null;\n }\n }\n class stack\n {\n constructor(data=[])\n {\n this.bottom=null;\n this.top=null;\n for(let i of data){\n this.push(i)\n }\n }\n copy(){\n let data=[]\n if (this.top == null)return null;\n let temp=this.top;\n while(temp!=null){\n data.push(temp.data)\n temp=temp.prev\n }\n return new stack(data)\n }\n delete(){\n this.bottom=null\n this.top=null\n }\n push(n){\n let temp =new node(n);\n if(this.bottom == null){\n this.bottom = temp;\n }\n else{\n temp.prev=this.top\n }\n this.top = temp;\n }\n display(){\n let temp = this.top;\n while(temp!=null){\n console.log(temp.data);\n temp = temp.prev;\n }\n }\n pop(){\n let deleted=this.bottom.data;\n this.bottom=this.bottom.prev;\n return deleted; }\n }\n"
      ]
    },
    "queue_enqueue_an_item": {
      "name": "Enqueue an item (add to end)",
      "code": [
        "queuedata.push(data)"
      ]
    },
    "queue_enqueue_not-implementedrity_item": {
      "name": "Enqueue a high not-implementedrity item (add to end of not-implementedrity queue)",
      "code": [
        "queuedata.push(data,not-implementedrity)"
      ]
    },
    "queue_enqueue_from_list": {
      "name": "Enqueue items from a list into queue (add list to end)",
      
      "not-implemented":"true"
    },
    "queue_enqueue_not-implementedrity_from_list": {
      "name": "Enqueue not-implementedrity items from a list (add list to end of not-implementedrity queue)",
      "code": [
        ""
      ]
    },
    "queue_dequeue_return_an_item": {
      "name": "Dequeue an item (remove from front, return item)",
      "code": [
        "queue.pop()"
      ]
    },
    "queue_dequeue_delete_an_item": {
      "name": "Dequeue an item (remove from front, don't return)",
      
      "not-implemented":"true"
      
    },
    "queue_peek_at_next_item": {
      "name": "Look/peek at next available element (from front)",
      "code": [
        "queue.front.next.data"
      ]
    },
    "queue_peek_at_last_item": {
      "name": "Look/peek at last element (from back)",
      "code": [
        "queue.rear.data"
      ]
    },
    "queue_duplicate_next_item": {
      "name": "Duplicate next item",
      
      "not-implemented":"true"
    },
    "queue_swap_two_items": {
      "name": "Swap two items",
      
      "not-implemented":"true"
    },
    "queue_get_size": {
      "name": "Get size (number of items) in the queue",
      "code": [
        "queue.length"
      ]
    },
    "queue_get_capacity": {
      "name": "Check capacity of queue",
      
      "not-implemented":"true"
    },
    "queue_export_to_list": {
      "name": "Export a list of all queue items",
      
      "not-implemented":"true"
    },
    "queue_clear_all": {
      "name": "Clear out all queue items",
      "code": [
        "queue = [] \n//Using linked list(implementation below) dataqueue.delete()"
      ]
    },
    "stack_push_item": {
      "name": "Push an item (add to top)",
      "code": [
        "stack.push(data)\n//Using linked list\nstackdata.push(data)"
      ]
    },
    "stack_pop_return_item": {
      "name": "Pop an item (remove from top, return item)",
      "code": [
        "stack.pop()\n//Using linked list\nstackdata.pop()"
      ]
    },
    "stack_pop_delete_item": {
      "name": "Pop an item (remove from top, don't return)",
      
      "not-implemented":"true"
    },
    "stack_peek_at_next_item": {
      "name": "Look/peek at next element (from top)",
      "code": [
        "//Linked list\nstack.top.prev.data"
      ]
    },
    "stack_peek_at_last_item": {
      "name": "Look/peek at last element (from bottom)",
      "code": [
        "//Linked list\nstack.bottom.data"
      ]
    },
    "stack_duplicate_next_item": {
      "name": "Duplicate top item",
      
      "not-implemented":"true"
    },
    "stack_swap_two_items": {
      "name": "Swap two items",
      
      "not-implemented":"true"

    },
    "stack_get_size": {
      "name": "Get size (number of items) on the stack",
      "code": [
        "stack.length"
      ]
    },
    "stack_get_capacity": {
      "name": "Check capacity of stack",
      "code": [
        ""
      ]
    },
    "stack_export_to_list": {
      "name": "Export a list of all stack items",
      
      "not-implemented":"true"

    },
    "stack_clear_all": {
      "name": "Clear all queue items",
      "code": [
        "stack = []\n//Using linked list\nstackdata.delete()"
      ]
    },
    "iterate_pointer_data_type": {
      "name": "Data type of a iterator pointer",
      "code": [
        "Reference"
      ]
    },
    "iterate_create_pointer": {
      "name": "Create iterator",
      "not-implemented":"true"

    },
    "iterate_move_to_next_item": {
      "name": "Move pointer to next item",
      "code": [
        "<Reference>.next"
      ]
    },
    "iterate_move_to_previous_item": {
      "name": "Move pointer to previous item",
      "code": [
        "<Reference>.prev"
      ]
    },
    "iterate_move_to_beginning": {
      "name": "Move pointer to beginning of queue/stack",
      "not-implemented":"true"

    },
    "iterate_move_to_end": {
      "name": "Move pointer to end of queue/stack",
      "not-implemented":"true"
    }
  }
}